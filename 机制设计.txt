这个是我自己要准备写的一个JQ插件，使元素悬停。当前版本不打算写批量选择，未来可能会写一个float-elements支持多选。

参考：
    edge浏览器收藏《自己写JQuery插件》

机制：
    选择元素
    选择该元素要响应滚动的容器
        或者说是要响应滚动的元素，不一定就是包含该元素的容器
    设置该元素要相对的容器（视窗）
    设置元素要悬停的位置
        条件：
            当元素抵达x轴某位置后
            当元素抵达y轴某位置后
            * 不设置的话就是该方法被使用那一时刻元素的位置
            * top, bottom, left, right值都是相对于"相对容器"而言的
            * 本来打算边距是基于client宽高，但是有些时候会用到半透明滚动条，所以还是基于整个块的宽高了，减个滚动条宽这个计算也不算太复杂。
    依据滚动事件悬停

接口：
    $(元素).floatElement
    (
        {
            respondTo:     该元素要响应滚动的容器
            relativeTo:    该元素定位要相对的容器
            listenType:    相对容器滚动条监听方式
            top:           元素向上滚动到此处时，悬停
            bottom:        元素向下滚动到此处时，悬停
            left:          元素向左滚动到此处时，悬停
            right:         元素向右滚动到此处时，悬停

            ...
        }
    );

示例：
    $("#weather-head").floatElement
    (
        {
            respondTo: "Window",
            relativeTo: ".table-container.weather",
            top: 51,
            bottom: "free",
        }
    );
    * 这个例子的意思是：
        元素 #weather-head 应用悬停

        元素响应 Window 容器的滚动条
        元素相对 .table-container.weather 容器作定位
        相对容器的滚动监听为 once(默认)
        元素向上方运动到距离容器上边 51px 距离时，发生悬停
            50px的视觉留白，1px的容器边框
        元素向下方运动不受限 free
        元素向左方运动禁止 initial(默认)
        元素向右方运动禁止 initial(默认)

/**************************************************************************************************/

/*
    respondTo:     该元素要响应滚动的容器
*/
/*////////////////////////////////////////////////////////////////////////////////////////////////*/
一般而言，响应滚动的容器和相对容器是同一个。







/*
    relativeTo:    该元素定位要相对的容器
*/
/*////////////////////////////////////////////////////////////////////////////////////////////////*/
一般而言，元素总是位于相对容器内的。

//--------------------------------------------------------------------------------------------------
e.g. relativeTo: "parent"
    +-------------------------------+
    |            ↑                  | relative-container
    |    +---------------+          |
    | ← | float-element |    →    |
    |    +---------------+          |
    |                               |
    |            ↓                  |
    |                               |
    |                               |
    +-------------------------------+

    此时的初始默认各边距为：
    top_away = 100
    bottom_away = 400
    left_away = 100
    right_away = 200

    * 如果想让视窗外的元素运动到距离视窗外某距离时悬停，将该边距值设为 a视窗宽+b外部边距 即可。

//--------------------------------------------------------------------------------------------------
e.g. relativeTo: "self"
    +-------------------------------+
    |            ↑                  | just-a-container
    |    +---------------+          |
    | ← | float-element |    →    |
    |    +---------------+          |
    |                               |
    |            ↓                  |
    |                               |
    |                               |
    +-------------------------------+

    此时的初始默认各边距为：
    top_away = 0
    bottom_away = 0
    left_away = 0
    right_away = 0






/*
    listenType:    相对容器滚动条监听方式
*/
/*////////////////////////////////////////////////////////////////////////////////////////////////*/

1.once
    在为元素添加悬停时，获取相对容器的位置大小等数据，之后的所有计算都基于该初始数据。
    如果使用的是once监听类型，当悬停元素、相对容器两者中有人发生大小位置变化后，要手动删除悬停性质，再新绑定。

2.always
    响应容器的滚动条，每当触发滚动事件，获取相对容器的位置大小等数据，之后的计算基于该最新数据。




/*
    top:           元素向上滚动到此处时，悬停
    bottom:        元素向下滚动到此处时，悬停
    left:          元素向左滚动到此处时，悬停
    right:         元素向右滚动到此处时，悬停
*/
/*////////////////////////////////////////////////////////////////////////////////////////////////*/

当边距为 0 ，表示元素边与容器边重合。
一般而言，边距应该定为：a 的视觉留白 + b 的容器边框



























































    内部的一些操作：
        1.设置元素定位为relative
        2.top,bottom,left,right这些值是指（元素定位值 - 容器定位值）
            元素的最上边(轴定位)距离其指定相对容器的最上边(轴定位)
            元素的最下边(轴定位)距离其指定相对容器的最下边(轴定位)
            元素的最左边(轴定位)距离其指定相对容器的最左边(轴定位)
            元素的最右边(轴定位)距离其指定相对容器的最右边(轴定位)
            * 一般来讲，元素都位于容器内
                元素上 - 容器上 > 0
                元素下 - 容器下 < 0
                元素左 - 容器左 > 0
                元素右 - 容器右 < 0
        3.允许元素在一个轴上悬停，仅当：
            元素在该轴所占长度 < 相对容器内容宽度
            * 否则元素会无限位移，容器滚动条无限拉长
            * chrome的滚动条大概在21px宽，实际操作中减掉30px的安全宽度吧
                const KEEPAWAY = 30;
                或者直接计算滚动条宽度 = 块.offsetWidth - 块.clientWidth
    需求的对象：
        要悬停的元素
        响应滚动容器
            "parent"指元素的父容器
        元素相对容器
        元素向上悬停距离
            "initial"指此插件使用时元素当前该边边距
        元素向下悬停距离
        元素向左悬停距离
        元素向右悬停距离

    内部变量：
        top_away_self       从自己的正常位置偏移开
        bottom_away_self    从自己的正常位置偏移开
        left_away_self      从自己的正常位置偏移开
        right_away_self     从自己的正常位置偏移开

    滚动条监听：
        滚动条监听有两种方式：
            1.是初始化时获取一次相对容器的位置数据，以该数据计算悬停元素的位移约束。
                如果相对容器位置发生变化，需要unbind一下scroll事件，再绑定一个新的。
            2.每当相对容器发生滚动事件时，就获取一次相对容器的位置数据，并以此计算约束。
                这种方式适合相对容器大小（宽高）经常发生变动的场合。
